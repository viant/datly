package cmd

import (
	"bytes"
	"context"
	"fmt"
	"github.com/viant/afs/file"
	"github.com/viant/afs/url"
	"github.com/viant/pgo"
	"github.com/viant/xreflect"
	"go/format"
	"golang.org/x/mod/modfile"
	"path"
	"strings"
	"time"
)

const (
	importsFile                = "init.go"
	importsDirectory           = "dependency"
	checksumDirectory          = "checksum"
	pluginDirectory            = "plugin"
	checksumFile               = "init.go"
	pluginFile                 = "main.go"
	customTypesModule          = "github.com/viant/xdatly/types/custom"
	coreTypesModule            = "github.com/viant/xdatly/types/core"
	generatedCustomTypesModule = "github.com/viant/xdatly/types/custom/checksum"
)

func (s *Builder) shouldGenPlugin(name string, types *xreflect.DirTypes) bool {
	methods := types.Methods(name)
	return len(methods) != 0
}

func (s *Builder) uploadPlugins() error {
	hasMod := map[string]string{}
	for _, pluginUrl := range s.plugins {
		if err := s.detectMod(pluginUrl, hasMod); err != nil {
			return err
		}
	}

	generated := map[string]bool{}
	for _, aPlugin := range s.plugins {
		modPath, ok := s.getModPath(aPlugin, hasMod)
		pluginPath := aPlugin.fileURL

		if ok && modPath != "" {
			if generated[modPath] {
				continue
			}

			pluginPath = modPath
			generated[modPath] = true
		}

		if err := s.genPlugin(aPlugin, pluginPath); err != nil {
			return err
		}
	}

	s.config.PluginsURL = s.options.PluginsURL
	return nil
}

func (s *Builder) detectMod(pluginMeta *pluginGenDeta, modules map[string]string) error {
	dir := pluginMeta.URL
	location := s.dsqlDir()
	upFolders := map[string]bool{}
	for len(location) > 1 {
		upFolders[location] = true
		location = path.Dir(location)
	}

	for len(dir) > 1 {
		list, err := s.fs.List(context.Background(), dir)
		if err != nil {
			return err
		}

		var modURL string
		for _, object := range list {
			base := path.Base(object.URL())
			if base == "go.mod" {
				modURL = strings.ReplaceAll(object.URL(), "file://localhost", "")
			}
		}

		if upFolders[dir] {
			boundlePath, ok := s.IsPluginBundle(dir)
			if ok {
				pluginMeta.fileURL = boundlePath
				modules[dir] = boundlePath
				pluginMeta.mainFile = path.Join("main.go")
			}

			return nil
		}

		if modURL != "" {
			modules[dir] = modURL
			return nil
		}

		dir = path.Dir(dir)
	}

	return nil
}

func (s *Builder) dsqlDir() string {
	if path.Ext(s.options.DSQLOutput) != "" {
		return path.Dir(s.options.DSQLOutput)
	}

	return s.options.DSQLOutput
}

func (s *Builder) getModPath(plugin *pluginGenDeta, mod map[string]string) (string, bool) {
	dir := path.Dir(plugin.URL)
	for len(dir) > 1 {
		if modPath, ok := mod[dir]; ok {
			return modPath, true
		}

		dir = path.Dir(dir)
	}

	return "", false
}

func (s *Builder) genPlugin(plugin *pluginGenDeta, aPath string) error {
	if s.options.IsPluginlessBuildMode() {
		return nil
	}

	var modPath string
	var sourceURL string
	var mainPath string
	if URL, ok := s.IsPluginBundle(aPath); ok {
		modPath = URL
		mainPath = path.Join(pluginDirectory, pluginFile)
		sourceURL = URL
	} else {
		sourceURL = aPath
		mainPath = aPath
	}

	pluginName := path.Base(aPath)
	if ext := path.Ext(pluginName); ext != "" {
		pluginName = strings.Replace(pluginName, ext, ".so", 1)
	} else {
		pluginName = pluginName + ".so"
	}

	pluginPath := url.Path(s.options.PluginsURL)
	if index := strings.Index(pluginPath, "/Datly"); index != -1 {
		pluginPath = pluginPath[index:]
	}

	destURL := s.options.PluginDst
	if destURL == "" {
		destURL = path.Join(s.options.WriteLocation, pluginPath)
	}

	if err := s.buildBinary(sourceURL, destURL, pluginName, mainPath, ""); err != nil {
		return err
	}

	if modPath != "" {
		if err := s.updateLastGenPluginMeta(modPath, time.Now()); err != nil {
			return err
		}
	}

	return nil
}

func (s *Builder) buildBinary(sourceURL string, destURL string, pluginName string, mainPath string, buildMod string) error {
	return pgo.Build(&pgo.Options{
		SourceURL:  sourceURL,
		DestURL:    destURL,
		Name:       pluginName,
		Arch:       s.options.PluginArch,
		Os:         s.options.PluginOS,
		Version:    s.options.PluginGoVersion,
		MainPath:   mainPath,
		BuildArgs:  s.options.PluginArgs,
		ModPath:    buildMod,
		WithLogger: true,
	})
}

func (s *Builder) updateLastGenPluginMeta(URL string, now time.Time) error {

	metaURL := path.Join(URL, checksumDirectory, checksumFile)
	content := fmt.Sprintf(`//Code generated by DATLY. DO NOT EDIT. GeneratedTime will be updated whenever new plugin was generated.
//Please use GeneratedTime to Register types. It will help to keep types synchronized when using plugins.

package %v

import "time"

var GeneratedTime, _ = time.Parse(time.RFC3339, "%v")
`, checksumDirectory, now.Format(time.RFC3339))

	formatted, err := format.Source([]byte(content))
	if err != nil {
		return err
	}

	return s.fs.Upload(context.Background(), metaURL, file.DefaultFileOsMode, bytes.NewReader(formatted))
}

func (s *Builder) IsPluginBundle(URL string) (string, bool) {
	if boundleURL, ok := s.bundles[URL]; ok {
		return boundleURL, boundleURL != ""
	}

	bundleURL, ok := s.isPluginBundle(URL)
	s.bundles[URL] = bundleURL
	return bundleURL, ok
}

func (s *Builder) isPluginBundle(URL string) (string, bool) {
	for len(URL) > 1 {
		if ext := path.Ext(URL); ext != "" {
			URL = strings.Replace(URL, ext, "", 1)
		}

		list, _ := s.fs.List(context.Background(), URL)

		for _, aFile := range list {
			fileURL := aFile.URL()
			if path.Base(fileURL) != "go.mod" {
				continue
			}

			fileContent, err := s.fs.DownloadWithURL(context.Background(), fileURL)
			if err != nil {
				return "", false
			}

			parse, err := modfile.Parse("go.mod", fileContent, nil)
			if err != nil {
				return "", false
			}

			if parse.Module.Mod.Path == customTypesModule {
				replace := strings.Replace(path.Dir(fileURL), "file://localhost", "", 1)
				replace = strings.Replace(replace, "file:/localhost", "", 1)
				return replace, true
			}

			return "", false
		}

		URL = path.Dir(URL)
	}

	return "", false
}
