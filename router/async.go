package router

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"github.com/viant/datly/cmd/env"
	"github.com/viant/datly/router/async"
	"github.com/viant/datly/router/async/db"
	"github.com/viant/datly/router/async/db/bigquery"
	"github.com/viant/datly/router/async/db/mysql"
	"github.com/viant/datly/router/async/handler/s3"
	"github.com/viant/datly/router/async/handler/sqs"
	"github.com/viant/datly/utils/types"
	"github.com/viant/datly/view"
	"github.com/viant/sqlx/io"
	"github.com/viant/sqlx/io/config"
	"github.com/viant/sqlx/io/insert"
	"github.com/viant/sqlx/io/update"
	"github.com/viant/sqlx/metadata/sink"
	"github.com/viant/sqlx/option"
	"reflect"
	"strings"
	"sync"
	"time"
	"unsafe"
)

type (
	Async struct {
		EnsureDBTable    bool
		Connector        *view.Connector
		PrincipalSubject string
		ExpiryTimeInS    int
		Dataset          string
		HandlerType      string
		BucketURL        string

		_asyncHandler async.Handler
		_matchers     sync.Map
		_qualifier    *qualifier
		_sqlSource    db.SqlSource
	}

	qualifier struct {
		parameter *view.Parameter
		accessor  *types.Accessor
	}
)

func (a *Async) Init(ctx context.Context, resource *view.Resource, mainView *view.View) error {
	if a.Connector == nil {
		return fmt.Errorf("async connector can't be empty")
	}

	if err := a.Connector.Init(ctx, resource.GetConnectors()); err != nil {
		return err
	}

	if err := a.initAccessor(resource); err != nil {
		return err
	}

	if err := a.initSqlSource(ctx); err != nil {
		return err
	}

	a.inheritHandlerTypeIfNeeded()

	if err := a.initHandlerIfNeeded(ctx); err != nil {
		return err
	}

	recordType := reflect.TypeOf(async.Record{})
	columns, err := a.ensureTable(ctx, recordType, view.AsyncJobsTable, true, false)
	if err != nil {
		return err
	}

	if err = a.checkTypeMatch(columns, recordType); err != nil {
		return err
	}

	return nil
}

func (a *Async) initAccessor(resource *view.Resource) error {
	if a.PrincipalSubject == "" {
		return nil
	}

	dotIndex := strings.Index(a.PrincipalSubject, ".")
	var paramName, path string
	if dotIndex != -1 {
		paramName, path = a.PrincipalSubject[:dotIndex], a.PrincipalSubject[dotIndex+1:]
	} else {
		paramName = a.PrincipalSubject
	}

	param, err := resource.LookupParameter(paramName)
	if err != nil {
		return err
	}

	var accessor *types.Accessor
	if path != "" {
		accessors := types.NewAccessors(&types.VeltyNamer{})
		accessors.InitPath(param.ActualParamType(), path)
		accessor, err = accessors.AccessorByName(path)

		if err != nil {
			return err
		}
	}

	a._qualifier = &qualifier{
		parameter: param,
		accessor:  accessor,
	}

	return nil
}

func (a *Async) ensureTable(ctx context.Context, recordType reflect.Type, tableName string, createIfNeeded bool, autogeneratedPk bool) ([]sink.Column, error) {
	aDb, err := a.Connector.DB()
	if err != nil {
		return nil, err
	}

	session, err := config.Session(ctx, aDb)
	if err != nil {
		return nil, err
	}

	columns, err := config.Columns(ctx, session, aDb, tableName)
	if err == nil && len(columns) > 0 {
		return columns, nil
	}

	if !createIfNeeded {
		return columns, fmt.Errorf("table %v doesn't exists", tableName)
	}

	tx, err := aDb.BeginTx(context.Background(), nil)
	if err != nil {
		return columns, err
	}

	asyncTable, err := a._sqlSource.CreateTable(recordType, tableName, view.AsyncTagName, autogeneratedPk)
	if err != nil {
		return nil, err
	}
	_, err = tx.Exec(asyncTable.SQL)
	if err != nil {
		_ = tx.Rollback()
		return columns, err
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}

	return config.Columns(ctx, session, aDb, tableName)
}

func (a *Async) checkTypeMatch(columns []sink.Column, recordType reflect.Type) error {
	for recordType.Kind() == reflect.Slice {
		recordType = recordType.Elem()
	}

	ioColumns := make([]io.Column, 0, len(columns))
	for _, column := range columns {
		ioColumns = append(ioColumns, io.NewColumn(column.Name, column.Type, nil))
	}

	matcher, err := a.getMatcher(recordType)
	if err != nil {
		return err
	}

	_, err = matcher.Match(recordType, ioColumns)
	return err
}

func (a *Async) initSqlSource(ctx context.Context) error {
	aDb, err := a.Connector.DB()
	if err != nil {
		return err
	}

	dialect, err := config.Dialect(ctx, aDb)
	if err != nil {
		return err
	}

	productName := strings.ToLower(dialect.Product.Name)
	if strings.Contains(productName, "mysql") {
		a._sqlSource = mysql.NewSQLSource()
		return nil
	}

	if strings.Contains(productName, "bigquery") {
		a._sqlSource, err = bigquery.NewSQLSource(a.Dataset)
		return err
	}

	return fmt.Errorf("unsupported async db %v", dialect.Product.Name)
}

func (a *Async) JobsInserter(ctx context.Context) (*insert.Service, error) {
	return a.inserter(ctx, view.AsyncJobsTable)
}

func (a *Async) inserter(ctx context.Context, table string, options ...option.Option) (*insert.Service, error) {
	aDb, err := a.Connector.DB()
	if err != nil {
		return nil, err
	}

	options = append(options, io.Resolve(io.NewResolver().Resolve))

	return insert.New(ctx, aDb, table, options...)
}

func (a *Async) JobsUpdater(ctx context.Context) (*update.Service, error) {
	return a.updater(ctx, view.AsyncJobsTable)
}

func (a *Async) RecordsInserter(ctx context.Context, route *Route) (*insert.Service, error) {
	return a.inserter(ctx, route.View.Async.Table, option.Tag(view.AsyncTagName))
}

func (a *Async) updater(ctx context.Context, table string) (*update.Service, error) {
	aDb, err := a.Connector.DB()
	if err != nil {
		return nil, err
	}

	return update.New(ctx, aDb, table)
}

func (a *Async) EnsureDestTableExists(ctx context.Context, record *async.Record, response *preparedResponse) error {
	createIfNeeded := record.DestinationCreateDisposition == async.CreateDispositionIfNeeded
	columns, err := a.ensureTable(ctx, reflect.TypeOf(response.objects), record.DestinationTable, createIfNeeded, true)
	if err != nil {
		return err
	}

	return a.checkTypeMatch(columns, reflect.TypeOf(response.objects))
}

func (a *Async) getMatcher(recordType reflect.Type) (*io.Matcher, error) {
	actualType := recordType
	value, ok := a._matchers.Load(actualType)
	if ok {
		return value.(*io.Matcher), nil
	}

	for recordType.Kind() == reflect.Slice {
		recordType = recordType.Elem()
	}

	matcher := io.NewMatcher("sqlx", func(column io.Column) func(pointer unsafe.Pointer) interface{} {
		return func(pointer unsafe.Pointer) interface{} {
			return reflect.New(column.ScanType()).Elem().Interface()
		}
	})

	a._matchers.Store(actualType, matcher)
	return matcher, nil
}

func (a *Async) initHandlerIfNeeded(ctx context.Context) error {
	handler, err := a.detectHandlerType(ctx)
	if err != nil {
		return err
	}

	a._asyncHandler = handler

	return nil
}

func (a *Async) detectHandlerType(ctx context.Context) (async.Handler, error) {
	switch strings.ToUpper(a.HandlerType) {
	case "S3":
		return s3.NewHandler(ctx, a.BucketURL)
	case "SQS":
		return sqs.NewHandler(ctx, "datly-jobs")

	case "":
		switch env.BuildType {
		case env.BuildTypeKindLambda:
			return sqs.NewHandler(ctx, "datly-async")

		default:
			return nil, nil
		}

	default:
		return nil, fmt.Errorf("unsupported async HandlerType %v", a.HandlerType)
	}
}

func (a *Async) inheritHandlerTypeIfNeeded() {
	switch env.BuildType {
	case env.BuildTypeKindLambdaSQS, env.BuildTypeKindLambdaS3:
		a.HandlerType = ""
		return
	}

	if a.HandlerType != "" {
		return
	}

	if a.BucketURL != "" {
		a.HandlerType = "S3"
		return
	}

}

func NewAsyncRecord(ctx context.Context, route *Route, request *RequestParams) (*async.Record, error) {
	headers := request.Header().Clone()
	Sanitize(request.request, route, headers, nil)

	marshal, err := json.Marshal(headers)
	if err != nil {
		return nil, err
	}

	recordID, err := uuid.NewUUID()
	if err != nil {
		return nil, err
	}

	principalSubject, err := PrincipalSubject(ctx, route, request)
	if err != nil {
		return nil, err
	}

	creationTime := time.Now()

	var destinationTable string
	if rAsync := route.View.Async; rAsync != nil {
		destinationTable = rAsync.Table
	}

	return &async.Record{
		JobID:   recordID.String(),
		State:   async.StateRunning,
		Metrics: "",
		RecordRequest: async.RecordRequest{
			RequestRouteURI: route.URI,
			RequestURI:      request.request.RequestURI,
			RequestHeader:   string(marshal),
			RequestMethod:   request.request.Method,
		},
		RecordPrincipal: async.RecordPrincipal{
			PrincipalUserEmail: nil,
			PrincipalSubject:   principalSubject,
		},
		RecordDestination: async.RecordDestination{
			DestinationTable:             destinationTable,
			DestinationCreateDisposition: async.CreateDispositionIfNeeded,
			DestinationSchema:            nil,
			DestinationTemplate:          nil,
			DestinationWriteDesposition:  nil,
		},
		MainView:     route.View.Name,
		Labels:       "",
		JobType:      string(route.Service),
		Error:        nil,
		CreationTime: creationTime,
	}, nil
}

func PrincipalSubject(ctx context.Context, route *Route, request *RequestParams) (*string, error) {
	rAsync := route.Async
	if rAsync == nil {
		return nil, nil
	}

	principal := rAsync._qualifier
	if principal == nil {
		return nil, nil
	}

	value, err := request.ExtractHttpParam(ctx, principal.parameter)
	if err == nil && principal.accessor != nil {
		value, _ = principal.accessor.Value(value)
	} else {
		return nil, nil
	}

	bytes, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}

	subj := string(bytes)
	return &subj, nil
}
