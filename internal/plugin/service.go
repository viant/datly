package plugin

/*

func (s *Builder) registerXDatlyGoFile(moduleBundle *bundleMetadata, outputURL string) error {
	var imports []string

	goModulePath := moduleBundle.moduleName
	if ok, _ := s.fs.Exists(context.Background(), goModulePath); !ok {
		goModulePath = moduleBundle.url
	}

	dirTypes, err := xreflect.ParseTypes(path.Join(goModulePath, importsDirectory), xreflect.WithTypeLookupFn(dConfig.Config.LookupType))
	if err == nil {
		imports = dirTypes.NonStandardPackages("*" + importsFile)
	}

	location := s.relativeOf(moduleBundle.url, outputURL, moduleBundle.moduleName)
	imports = append(imports, location)
	result := &bytes.Buffer{}
	result.WriteString(`// Code generated by DATLY. Append sideefect imports here.

		package dependency

		import (`)

	imported := map[string]bool{}
	for _, packageName := range imports {
		if imported[packageName] {
			continue
		}

		result.WriteString(fmt.Sprintf(`
		_ "%v"
`, packageName))

		imported[packageName] = true
	}

	result.WriteString("\n)")

	source, err := goFormat.Source(result.Bytes())
	if err != nil {
		return fmt.Errorf("failed to generate dep go code: %w, %s", err, source)
	}

	registryURL := path.Join(moduleBundle.url, importsDirectory, importsFile)
	shouldInitXDatlyMod := moduleBundle != nil && moduleBundle.shouldInitXDatlyModule()
	if shouldInitXDatlyMod {
		_ = s.fs.Create(context.Background(), path.Dir(registryURL), file.DefaultDirOsMode, true)
	}

	if err = s.fs.Upload(context.Background(), registryURL, file.DefaultFileOsMode, bytes.NewReader(source)); err != nil {
		return err
	}

	if shouldInitXDatlyMod {
		if err = s.ensureSideefectsImports(moduleBundle); err != nil {
			return err
		}

		if err = s.ensureChecksum(moduleBundle); err != nil {
			return err
		}

		if err = s.ensurePlugins(moduleBundle); err != nil {
			return err
		}
	}

	return nil
}

*/
