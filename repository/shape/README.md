# repository/shape

`repository/shape` provides a dynamic, in-memory pipeline for building Datly runtime artifacts from either:

- Go structs (`scan -> plan -> load`)
- DQL (`compile -> load`)

without generating YAML route/resource files.

## Packages

- `shape/scan`: discovers view/state tags from struct fields (Embedder-aware).
- `shape/plan`: normalizes scan output into a deterministic shape plan.
- `shape/load`: materializes `view.Resource`, `view.View`, and a runtime-neutral component artifact.
- `shape/compile`: compiles DQL into a shape plan for dynamic loading.

## Facade API

Use `shape.Engine` or package helpers:

- `shape.LoadViews(ctx, src, opts...)`
- `shape.LoadComponent(ctx, src, opts...)`
- `shape.LoadDQLViews(ctx, dql, opts...)`
- `shape.LoadDQLComponent(ctx, dql, opts...)`

## Minimal Struct Flow

```go
engine := shape.New(
    shape.WithScanner(scan.New()),
    shape.WithPlanner(plan.New()),
    shape.WithLoader(load.New()),
    shape.WithName("/v1/api/report"),
)

views, err := engine.LoadViews(ctx, &MyOutput{})
```

## Minimal DQL Flow

```go
engine := shape.New(
    shape.WithCompiler(compile.New()),
    shape.WithLoader(load.New()),
    shape.WithName("/v1/api/report"),
)

component, err := engine.LoadDQLComponent(ctx, "SELECT id FROM ORDERS t")
```

## Repository Integration

`repository/components.go` can optionally merge views generated by the shape pipeline during init.

Enable via:

```go
repository.WithShapePipeline(true)
```

Default is disabled to preserve existing behavior.
